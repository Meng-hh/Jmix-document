= DataContext
:page-aliases: backoffice-ui:data/data-context.adoc

使用merge()方法的主要规则是继续处理返回的实例并丢弃传递的实例。在大多数情况下，返回的对象实例将是不同的。唯一的例外是，当您将先前从merge()或find()的另一个上下文调用中返回的实例传递给merge()时。

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/DepartmentBrowseData2.java[tags=data-context;data-manager;collection;load]
----

A single instance of `DataContext` exists for a given screen and all its nested fragments. It is created if the `<data>` element exists in the screen XML descriptor.

The `<data>` element can have `readOnly="true"` attribute, in that case, a special "no-op" implementation is used that actually doesn’t track entities and hence doesn’t affect performance. By default, entity browsers scaffolded by Studio have the read-only data context, so if you need to track changes and commit dirty entities in a browser, remove the `readOnly="true"` XML attribute.

[[obtaining-data-context]]
== Obtaining DataContext

. `DataContext` of a screen can be obtained in its controller using injection:
+
[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/DepartmentBrowseData2.java[tags=data-context]
----
+
. If you have a reference to a screen, you can get its `DataContext` using the `UiControllerUtils` class:
+
[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/DepartmentBrowseData.java[tags=sample-method]
----
+
. A UI component can obtain `DataContext` of the current screen as follows:
+
[source,java,indent=0]
----
DataContext dataContext = UiControllerUtils.getScreenData(getFrame().getFrameOwner()).getDataContext();
----

[[parent-data-context]]
== Parent DataContext

DataContext instances can form parent-child relationships. If a `DataContext` instance has parent context, it commits changed entities to the parent instead of saving them to the data store. This feature enables editing compositions when detail entities are saved only together with the master entity. If an entity attribute is annotated with `@Composition`, the framework automatically sets parent context in the attribute editor screen, so the changed attribute entity will be saved to the data context of the master entity.

You can easily provide the same behavior for any entities and screens.

If you open an edit screen that should commit data to the current screen’s data context, use the `withParentDataContext()` method of the builder:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/PersonBrowseCondition.java[tags=screen-builders;data-context;person-edit]
----

If you open a simple screen using the `Screens` bean, provide a setter method accepting the parent data context:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/SmplScreen.java[tags=sample-screen]
----

And use it after creating the screen:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/PersonBrowseCondition.java[tags=screens;data-context;sample-screen]
----

CAUTION: Make sure that the parent data context is not defined with `readOnly="true"` attribute. Otherwise, you will get an exception when trying to use it as a parent for another context.

[[data-context-events]]
== Events and Handlers

This section describes the DataContext lifecycle events that can be handled in screen controllers.

include::events-handlers-generation-data-tip.adoc[]

image::data/data-events.png[align="center"]

[[data-change]]
=== ChangeEvent

This event is sent when the context detects changes in a tracked entity: a new instance is merged or an entity is removed.

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/CustomerBrowseDataContextEvents.java[tags=change-event]
----

[[data-post-commit]]
=== PostCommitEvent

This event is sent after committing changes.
In the corresponding event listener, you can get the collection of committed entities returned from the middle tier, for example:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/CustomerBrowseDataContextEvents.java[tags=post-commit-event]
----

[[data-pre-commit]]
=== PreCommitEvent

This event is sent before committing changes.
In this event listener, you can add arbitrary entity instances to the committed collections returned by `getModifiedInstances()` and `getRemovedInstances()` methods, for example:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/CustomerBrowseDataContextEvents.java[tags=pre-commit-event]
----

You can also prevent the commit using the `preventCommit()` method of the event, for example:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/CustomerBrowsePreCommitEvent.java[tags=prevent-commit]
----

[[commit-delegate]]
=== CommitDelegate

The standard behavior of Jmix UI components suggests CRUD operations on JPA entities. In case of data binding to DTO entities you need to override the built-in logic of working with data context.

The `commitDelegate` handler allows you to access the `SaveContext` object containing the modified entity instances. Use it to specify the custom xref:data-access:data-manager.adoc#save[save logic], for example:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/CustomerBrowseDataContextEvents.java[tags=commit-delegate]
----